---
name: syncing-codex-harness
description: >-
  Syncs Claude Code harness to Codex CLI compatible format. Projects skills,
  agents, MCP servers, and rules into .agents/ and .codex/ directories.
  Use when "codex sync", "codex harness", "codex 동기화", "codex 투영",
  or making a project work with Codex CLI.
allowed-tools: Bash(*)
---

# Claude Code -> Codex CLI Harness Sync

이 스킬은 현재 프로젝트의 Claude Code 하니스(스킬, 에이전트, MCP, 규칙)를
Codex CLI 호환 구조(`.agents/`, `.codex/`)로 프로젝션한다.

`sync.sh` 스크립트 경로: `<이 스킬 디렉토리>/references/sync.sh`

## Step 1: 소스 감지 (Detection)

프로젝트의 Claude Code 하니스 유형을 파악:

```bash
# 로컬 스킬 확인
LOCAL_SKILLS=0
if [ -d ".claude/skills" ]; then
  LOCAL_SKILLS=$(ls -d .claude/skills/*/SKILL.md 2>/dev/null | wc -l | tr -d ' ')
fi

# 플러그인 확인
PLUGIN_KEYS=()
if [ -f ".claude/settings.local.json" ]; then
  # enabledPlugins에서 true인 키 추출
  PLUGIN_KEYS=($(python3 -c "
import json, sys
try:
  d = json.load(open('.claude/settings.local.json'))
  for k, v in d.get('enabledPlugins', {}).items():
    if v: print(k)
except: pass
" 2>/dev/null))
fi
```

| 결과 | 케이스 |
|------|--------|
| `LOCAL_SKILLS > 0`, 플러그인 없음 | Case A: 로컬 스킬만 |
| `LOCAL_SKILLS == 0`, 플러그인 있음 | Case B: 플러그인 기반 |
| 둘 다 있음 | Case C: 혼합 |
| 둘 다 없음 | Case D: 최소 (AGENTS.md만) |

## Step 2: 플러그인 해석 (Plugin Resolution)

플러그인 키마다 installPath를 찾는다:

```bash
resolve_plugin() {
  local plugin_key="$1"  # e.g. "zaritalk-front@zaritalk-plugins"
  local manifest="$HOME/.claude/plugins/installed_plugins.json"

  python3 -c "
import json, os, sys
manifest = json.load(open('$manifest'))
entries = manifest.get('plugins', {}).get('$plugin_key', [])
pwd = os.getcwd()
for e in entries:
    scope = e.get('scope', '')
    if scope == 'user':
        print(e['installPath']); sys.exit(0)
    if scope == 'local' and e.get('projectPath', '') == pwd:
        print(e['installPath']); sys.exit(0)
print(''); sys.exit(1)
" 2>/dev/null
}
```

매칭 규칙:
- `scope: "local"` -> `projectPath`가 `$PWD`와 정확히 일치
- `scope: "user"` -> 항상 적용
- 매칭 실패 -> 경고 후 건너뛰기

## Step 3: 전체 재생성 (Full Regeneration)

### 3.1 초기화

```bash
SYNC_SH="<이 스킬 디렉토리>/references/sync.sh"
bash "$SYNC_SH" init "$PWD"
```

### 3.2 AGENTS.md 생성

우선순위:
1. 프로젝트에 `CLAUDE.md` 존재 -> 심링크: `ln -sfn CLAUDE.md AGENTS.md`
2. 프로젝트에 `CLAUDE.md` 없지만 플러그인이 CLAUDE.md 제공 -> 플러그인 CLAUDE.md를 `AGENTS.md`로 복사
3. 둘 다 없음 -> 건너뛰기, 경고

### 3.3 로컬 스킬 프로젝션

```bash
LOCAL_COUNT=$(bash "$SYNC_SH" project-skills .claude/skills .agents/skills)
```

### 3.4 플러그인 스킬 프로젝션

각 플러그인의 installPath에서:

```bash
INSTALL_PATH="<resolved installPath>"
PLUGIN_NAME="<plugin-key에서 @ 앞부분>"  # e.g. "zaritalk-front"
PLUGIN_COUNT=$(bash "$SYNC_SH" plugin-skills "$INSTALL_PATH/skills" .agents/skills --plugin-name="$PLUGIN_NAME")
```

### 3.5 에이전트 프로젝션

플러그인의 agents 디렉토리에서:

```bash
if [ -d "$INSTALL_PATH/agents" ]; then
  AGENT_COUNT=$(bash "$SYNC_SH" agents "$INSTALL_PATH/agents" .agents)
fi
```

### 3.6 Rules + 플러그인 CLAUDE.md -> AGENTS.override.md

자동생성 섹션 내용을 구성한다:

1. **플러그인 rules** (`{installPath}/rules/*.md`):
   - 각 rule 파일의 YAML frontmatter를 제거하고 마크다운 본문만 추출
   - `## Rule: {filename}` 헤딩으로 구분

2. **플러그인 CLAUDE.md**:
   - 프로젝트 CLAUDE.md와 별개인 플러그인 고유 지침
   - `## Plugin Instructions ({plugin-name})` 헤딩으로 포함

3. **Codex 공통 보충**:
   ```
   ## 스킬 사용
   - `.agents/skills/`에서 스킬이 자동 발견된다
   - `/skill-name`은 Codex에서 `$skill-name`에 대응
   - Claude Code 전용 기능(hooks, plugins, MCP UI)은 Codex에서 미지원
   ```

마커 기반 교체:
```
<!-- AUTO-GENERATED BY syncing-codex-harness -->
{auto-generated content}
<!-- END AUTO-GENERATED BY syncing-codex-harness -->
```

AGENTS.override.md가 이미 존재하면 마커 내부만 교체, 외부는 보존.
없으면 새로 생성 (참조: `references/agents-override-template.md`).

### 3.7 MCP 변환

두 소스 처리 (참조: `references/mcp-conversion.md`):

**3.7a: 프로젝트 루트 `.mcp.json`**
- `${CLAUDE_PLUGIN_ROOT}` 치환 불필요

**3.7b: 플러그인 `.mcp.json`** (`{installPath}/.mcp.json`)
- `${CLAUDE_PLUGIN_ROOT}`를 installPath 절대경로로 치환

변환 규칙:
- `command` + `args` (stdio) -> `[mcp_servers.{name}]` TOML 섹션
- `type: "http"` + `url` -> `[mcp_servers.{name}]` url 키
- `env` -> `[mcp_servers.{name}.env]` 하위 섹션

출력: `.codex/config.toml`
- 이미 존재하면 `[mcp_servers.*]` 섹션만 교체
- 없으면 MCP 섹션만으로 새로 생성

Python으로 변환:

```python
import json, os

def convert_mcp(mcp_json_path, install_path=None):
    """Returns TOML string for [mcp_servers.*] sections."""
    with open(mcp_json_path) as f:
        servers = json.load(f)

    lines = []
    for name, cfg in servers.items():
        # Substitute ${CLAUDE_PLUGIN_ROOT}
        cfg_str = json.dumps(cfg)
        if install_path:
            cfg_str = cfg_str.replace("${CLAUDE_PLUGIN_ROOT}", install_path)
        cfg = json.loads(cfg_str)

        lines.append(f"\n[mcp_servers.{name}]")

        if cfg.get("type") == "http" and "url" in cfg:
            lines.append(f'url = "{cfg["url"]}"')
        elif "command" in cfg:
            lines.append(f'command = "{cfg["command"]}"')
            if "args" in cfg:
                args_str = ", ".join(f'"{a}"' for a in cfg["args"])
                lines.append(f"args = [{args_str}]")

        if "env" in cfg:
            lines.append(f"\n[mcp_servers.{name}.env]")
            for k, v in cfg["env"].items():
                lines.append(f'{k} = "{v}"')

    return "\n".join(lines)
```

### 3.8 .gitignore 확인

```bash
MISSING=$(bash "$SYNC_SH" gitignore-check "$PWD")
```

누락된 엔트리가 있으면 사용자에게 추가를 제안한다. **자동으로 수정하지 않는다.**

### 3.9 결과 리포트

프로젝션 결과를 요약:
- 로컬 스킬: N개
- 플러그인 스킬: N개
- 에이전트: N개
- MCP 서버: N개
- 규칙: N개
- 경고사항 (누락된 CLAUDE.md, 찾을 수 없는 플러그인, 이름 충돌 등)

## Edge Cases

| 상황 | 처리 |
|------|------|
| CLAUDE.md 없음 + 플러그인 CLAUDE.md 있음 | 플러그인 CLAUDE.md를 AGENTS.md로 복사 |
| CLAUDE.md 없음 + 플러그인 없음 | AGENTS.md 건너뛰기, 경고 |
| 스킬/플러그인 없음 | AGENTS.md만 생성, 경고 |
| 플러그인 캐시 경로 미존재 | 경고 후 건너뛰기 |
| 스킬 이름 충돌 (로컬 vs 플러그인) | 플러그인 스킬에 `{plugin-name}--` 접두사 |
| AGENTS.override.md 사용자 커스텀 보존 | 마커 외부 내용 유지 |
| `.codex/config.toml` 기존 설정 보존 | `[mcp_servers.*]` 섹션만 교체 |
| Worktree 경로 | `$PWD`로 매칭 |

## 참조 문서

- `references/sync.sh` — 기계적 프로젝션 셸 스크립트
- `references/mcp-conversion.md` — MCP JSON->TOML 변환 가이드
- `references/openai-yaml-generation.md` — openai.yaml 생성 절차
- `references/agents-override-template.md` — AGENTS.override.md 템플릿
- `references/codex-structure.md` — Codex 프로젝트 구조 레퍼런스
